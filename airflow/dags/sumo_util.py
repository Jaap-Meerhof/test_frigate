from lxml import etree as etree
import random
import igraph as ig
import sh

def get_plainxml_net(g, nod_xml_filen, edg_xml_filen, net_xml_filen):
    """
    Converts an igraph graph to a SUMO plain XML road network file.

    arguments:
        g : igraph graph. Nodes must have the 'x' and 'y' coordinate attributes.
        nod_xml_filen: output node SUMO file name
        edg_xml_filen: output edge SUMO file name
        net_xml_filen: output SUMO NET name
        
    returns:
        None
    """
    
    # generate nodes XML file
    nodes = etree.Element('nodes')
    nodes.append(etree.Comment('Automatically generated by AGR'))
    for v in g.vs():
        node = etree.SubElement(nodes, 'node', {"id":"n%d"%v.index, "x":str(v["x"]), "y":str(v["y"]), "type":"unregulated"})
        node.append(etree.Comment('Generated by AGR'))
    xml_string = etree.tostring(nodes, pretty_print=True)
    xml_out = open(nod_xml_filen, "wb")
    xml_out.write(xml_string)
    
    # generate edges XML file
    edges = etree.Element('edges')
    edges.append(etree.Comment('Automatically generated by AGR'))
    for e in g.es():
        edge = etree.SubElement(edges, 'edge', {"id":"e%d"%e.index, "priority":"1", "from":"n%d"%e.source, "to":"n%d"%e.target, "numLanes":"1"} )
        edge.append(etree.Comment('Automatically generated by AGR'))        
    xml_string = etree.tostring(edges, pretty_print=True)
    xml_out = open(edg_xml_filen, "wb")
    xml_out.write(xml_string)

    # generate SUMO NET file with SUMO's netconvert command
    # netconvert --node-files=MyNodes.nod.xml --edge-files=MyEdges.edg.xml --output-file=MySUMONet.net.xml
    cmd = sh.netconvert.bake(f"--node-files={nod_xml_filen}", f"--edge-files={edg_xml_filen}", f"--output-file={net_xml_filen}")
    print(cmd)
    out = cmd()
    print(out)


def generate_traffic_sp(g, num_vehicles, sources, targets, routes_xml_filen, depart_step = 1):
    """
    Generates traffic routes between sources and targets 
    by means of Dijkstra shortest-paths by minimizing the hop count.
    """
      
    routes = etree.Element('routes')
    depart = 0.0
    for v in range(num_vehicles):
        vehicle = etree.SubElement(routes, 'vehicle', {"id":"v%d"%v, "depart":"%0.2f"%depart})
        
        source = random.choice(sources)
        target = random.choice(targets)
        ends = [source, target]
        
        # minimize hop count
        sp = g.get_shortest_paths(ends[0], to=ends[1], mode=ig.OUT, output="epath")
        edges = " ".join( ["e%d"%eid for eid in sp[0] ] )
        route = etree.SubElement(vehicle, 'route', {"edges": edges })
        
        depart += depart_step

    xml_string = etree.tostring(routes, pretty_print=True)
    xml_out = open(routes_xml_filen, "wb")
    xml_out.write(xml_string)


def get_random_path(g, source, target):
    """
    Generates a random path between the given source and target.
    NOTE: this is unlikely to finish in anything that is not a DAG
    """
    path = []
    nextt = None
    current = source
    while current != target:        
        nextt = random.choice( g.neighbors(current, mode=ig.OUT) )
        path.append( g.get_eid( current, nextt ) )
        current = nextt

    return path

def generate_traffic_rnd(g, num_vehicles, sources, targets, routes_xml_filen, depart_step = 1):
    """
    Generates random traffic routes between the sources and targets.
    NOTE: this is likely to get in an infinite loop for non-DAG road networks.
    """
      
    routes = etree.Element('routes')
    depart = 0.0
    for v in range(num_vehicles):
        vehicle = etree.SubElement(routes, 'vehicle', {"id":"v%d"%v, "depart":"%0.2f"%depart})
        
        source = random.choice(sources)
        target = random.choice(targets)
                
        # minimize hop count
        rp = get_random_path(g, source, target)
        print(f"source = {source} target = {target} path = {rp}")
        assert g.es[rp[0]].source == source and g.es[rp[-1]].target == target
        
        edges = " ".join( ["e%d"%eid for eid in rp] )
        route = etree.SubElement(vehicle, 'route', {"edges": edges })
        
        depart += depart_step

    xml_string = etree.tostring(routes, pretty_print=True)
    xml_out = open(routes_xml_filen, "wb")
    xml_out.write(xml_string)